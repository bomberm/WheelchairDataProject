\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}

%slightly modified from stackoverflow @ https://tex.stackexchange.com/questions/200437/numbering-sections-subsections-etc-manually
%code block below allows for references to function as a section instead of a chapter
\makeatletter
\renewenvironment{thebibliography}[1]
{\subsection{References}
	\@mkboth{\MakeUppercase\bibname}{\MakeUppercase\bibname}%
	\list{\@biblabel{\@arabic\c@enumiv}}%
	{\settowidth\labelwidth{\@biblabel{#1}}%
		\leftmargin\labelwidth
		\advance\leftmargin\labelsep
		\@openbib@code
		\usecounter{enumiv}%
		\let\p@enumiv\@empty
		\renewcommand\theenumiv{\@arabic\c@enumiv}}%
%	\sloppy
	\clubpenalty4000
	\@clubpenalty \clubpenalty
	\widowpenalty4000%
	\sfcode`\.\@m}
{\def\@noitemerr
	{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist}
\makeatother

\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\makeindex
\usepackage{geometry}
\usepackage{float}
\usepackage{caption}

\geometry{textheight=9.5in, textwidth=7in}

% 1. Fill in these details
\def \CapstoneTeamName{		Wheelchair Data Collection Team}
\def \CapstoneTeamNumber{		4}
\def \GroupMemberOne{			Marie Bomber}
\def \GroupMemberTwo{			Aaron Leondar}
\def \GroupMemberThree{			Hadi Rahal-Arabi}
\def \CapstoneProjectName{			Robotic Wheelchair Data Collection and Analysis}
\def \CapstoneSponsorCompany{	Oregon State University}
\def \CapstoneSponsorPerson{	Matthew William Shuman	}

% 2. Uncomment the appropriate line below so that the document type works
\def \DocType{	%Problem Statement
				%Requirements Document
				%Technology Review
				%Design Document
					Midterm Progress Report
				}
\bibliographystyle{ieeetran}	
\newcommand{\NameSigPair}[1]{\par
\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill		\makebox[.75in]{\hrulefill}}
\par\vspace{-12pt} \textit{\tiny\noindent
\makebox[2.75in]{} \hfil		\makebox[3.25in]{\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}}}}
% 3. If the document is not to be signed, uncomment the RENEWcommand below
%\renewcommand{\NameSigPair}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{titlepage}
    \pagenumbering{gobble}
    \begin{singlespace}
        \hfill 
        % 4. If you have a logo, use this includegraphics command to put it on the coversheet.
        %\includegraphics[height=4cm]{CompanyLogo}   
        \par\vspace{.2in}
        \centering
        \scshape{
            \huge CS Capstone \DocType \par
            {\large 16 February 2018}\par
            \vspace{.5in}
            \textbf{\Huge\CapstoneProjectName}\par
            \vfill
            {\large Prepared for}\par
            \Huge \CapstoneSponsorCompany\par
            \vspace{5pt}
            {\Large\NameSigPair{\CapstoneSponsorPerson}\par}
            {\large Prepared by }\par
            Group\CapstoneTeamNumber\par
            % 5. comment out the line below this one if you do not wish to name your team
            \CapstoneTeamName\par 
            \vspace{5pt}
            {\Large
                \NameSigPair{\GroupMemberOne}\par
                \NameSigPair{\GroupMemberTwo}\par
                \NameSigPair{\GroupMemberThree}\par
            }
            \vspace{20pt}
				\begin{abstract}
INSERT ABSTRACT HERE
				\end{abstract} 
        }   
    \end{singlespace}
\end{titlepage}
\newpage
\pagenumbering{arabic}
\tableofcontents
%\listoffigures
%\listoftables
\clearpage


\section{Introduction}
%Project purposes and goals go here
\subsection{Project Purpose}
Robotic testing, more specifically robot data collection, has been an area that, while well-documented, is not well optimized. The time and amount of commands needed in order to set up a ROS environment to record test data is quite a lot. For example, to set up an environment to record tests with Project Chiron, around 10+ commands must be inputted in several different windows. The purpose of this project is to create an interface that is able to make the whole process of collecting data using ROS easier, from setup to data collection to data playback and storage. If the process of setting up tests to be able to collect data is made easier and made more streamlined, then it opens the door for even people who know nothing about ROS to still be able to run tests and collect data. It has the ability to not only satisfy research needs, but also can be useful in everyday situations, where any random person is able to use it effectively and run the same kinds of tests that a researcher can run.
\subsection{Project Goals}
The goals of this project are to simplify all the ROS connection commands and data collection setup into one simple interface. Doing so allows the entire process to be streamlined and eliminates the need to remember the list of complex commands needed to start recording manually. If the complexity is able to be taken out of the data recording process, then that means an expert in ROS will no longer have to be a requirement in order to set up and record a test. A researcher has the potential to hire a freshman undergraduate who knows little to nothing about robots, ROS, or even Computer Science, and the freshman will be able to create and run tests for the researcher. This allows the researcher to not have to worry about the testing aspect of their research, and can focus their efforts on more complicated research, as well as focusing on using the data that was collected and applying it to their research. If the goal of creating a simplified interface can be met, then the interface can be applied to more than just the project here. It has the potential to be released as open-source software to be used with any robot that runs ROS.
\section{Project Status}
The ROS Test Controller project has evolved quite a bit from the original inception in September 2017. What was originally conceived as a single use application to help meet the needs of our client as he collected testing data for Project Chiron, has evolved into a reusable interface to assist users of ROS design and run robotics tests. In addition, while we initially intended for the interface to run entirely in Python (as we expected the primary users to be more comfortable in Python and therefore, enhance maintainability) we have instead shifted into a NodeJS based web application. This primary shift came about due to Python having limited libraries for using SSH, the primary method of communicating with a robot using ROS. While the specifics of the connection issues will be addressed the next section, suffice to say the shift from a Python solution to a NodeJS solution broke a nearly two week block in project progress. 

As of February 14th, we were able to solve our connection issue by moving to a web application and will be testing the ‘bare-bones’ solution to our client on Monday the 19th. This mini-version of the application will focus on the client’s primary need, an interface that requires only one or two clicks to start, record and end a test.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{BarebonesMockup.jpg}
	\centering
	\caption{Mockup of 'Bare-Bones' interface}
\end{figure}

Currently, the client must have four terminals open and run 3 startup scripts before the robot is prepared to begin a test and then yet another command for the test to begin. This interface will automatically run the startup scripts for the client and transition beginning and ending a test to a single button click. 

Once we have successfully tested the ‘bare-bones’ solution, the client will be able to use the bare-bones solution while we expand the application. Our next stage will add creation of new tests (so that the same interface can be used for multiple robots and test scenarios) as well as the ability to view previous test results. This will mean that the design, recording and viewing of robotics tests will be contained within the interface. Mockups for both new functions and general application flow are included in Section 4. 


\section{Aaron's Individual Section}

Current Status

We have just completed a barebones alpha of our interface in Node.js. We originally started in Python, but ran into several problems that impeded progress. The only parts of our project that are actually in working condition is using the interface to connect to the wheelchair robot, launch the pre-determined roslaunch files that were given to us by our client, then run the recording function to collect data in a bag. The bag is then stored in specific folder on the Robot's NUC and can be retrieved later. Its functionality right now is basically that it solely functions with the Project Chiron Permobil wheelchair, and no other robot that runs ROS.

What's Left To Do

The main goal to focus on now is to expand functionality to a general use-case, so that the interface can be used with any robot that is able to run ROS, not just the Project Chiron wheelchair. The functions that will need to be added includes the ability to create new tests, select certain topics to record from a list, save tests so they can be run again later without having to waste time inputting all the parameters again, and divide users into researchers, who have a lot more freedom with the interface, and testers, who just have freedom to create and record tests. Also, other tasks to work on are making the interface look appealing and efficient, so that users will be able to learn its functions very quickly and will be able to remember those actions. Finally, the other important task is to document everything about our interface, from how it works with connectivity and recording, to how to run a sample test, in order to be able to release it in the future as an open-source project.

Problems/Solutions

We had problems that needed to be addressed since finals week of Fall term. During that week, we held a meeting with our client in order to get some hands-on experience with the Project Chiron wheelchair, so that we knew what we were working with. The problems that cropped up due to that meeting were that we were approaching the project slightly differently than our client wanted. We were designing the interface to exclusively with the Project Chiron Permobil wheelchair, however our client wanted something that used more of a general use case. So we had to redesign our requirements and design documents to not only include the requirements the Project Chiron wheelchair, but also include requirements for a general use case, so that the interface can be run on any robot that is able to run ROS. Another problem that needed to be addressed and fixed due to that meeting was that we needed to separate the two different types of users who would use this interface: the researchers and the testers. We originally planned the interface to behave the same no matter who was accessing it. The problems with this method became apparent in our meeting because testers who would use the interface would have access to all of the data collected, and that is something that we do not want to happen. So to solve that problem we had to split the users into the researchers and testers. Researchers would have freedom to create and record tests, be able to play back tests, and most importantly, be able to export the data collection to be used for various research projects/purposes. In contrast, testers should not have nearly that much freedom, and should only be able to create new tests and to be able to actually record the tests. The testers should not have any access to any of the actual information that is recorded in the bag file. Due to these problems that came to light because of our meeting, we had to edit our Requirements and Design documents in January, and get them re-verified and re-approved by our client before we could actually start development. Possibly the biggest problem that we have run into since starting this project has been being able to run a ROS environment remotely through ssh. Normally, when setting up and running a ROS environment, it is done within the command line on the same machine that is running the interface. However, because our interface aims to reduce the number of commands that the user has to input, the problem arises that suddenly we have run all of the ROS commands through python code, as opposed to just through the command line, and Python does not like that. Python already does not handle ssh connections well, preferring instead to use ftp, and when python is used to ssh into a robot, the source environment used to run ROS is missing. In short, Python being used to ssh into a robot and run ROS commands does not work well if a command line is not present, which it should not be, otherwise our interface would be completely pointless. The latest problem we have had to deal with has been switching away from Python to a language that supports what we are trying to do with our interface better, which we found to be Node.js. Only one member of our group has ever had experience with Node, and it was a decision that was made a couple weeks before the mid-way point in the term, so it was something that had to be implemented very quickly. However, it is a decision that we think will be more beneficial in the long run, as it will make adding additional features easier in the future, and will make the code way less messy and be way more functional.

Relavent/Interesting Information

What's interesting about our interface is that it is made in Node.js, which is a language that none of the members of our group have any significant experience working in, and two of us have absolutely zero experience working in it. Also, because our Python interface was determined to be bad and was scrapped so close to the mid-term, our bare bones Node interface had to be written in a matter of a couple of days, compared to our Python interface which took about 3-4 weeks.

\section{Interface Mockups}
INSERT BOTH MOCK-UPS AND GENERAL EXPLANATION OF UI RESEARCH DONE HERE - Detail both UI concerns but also code concerns. 

\bibliography{ProjectBib}

\end{document}